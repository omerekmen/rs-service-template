name: CD

on:
  push:
    branches: [ master, release ]
    tags: [ 'v*' ]

env:
  CARGO_TERM_COLOR: always
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        service: [api, worker, grpc, cli]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-${{ matrix.service }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        build-args: |
          SERVICE_NAME=${{ matrix.service }}
        cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-${{ matrix.service }}:buildcache
        cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-${{ matrix.service }}:buildcache,mode=max
        platforms: linux/amd64

  deploy-dev:
    name: Deploy to Dev Environment
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/master'
    environment:
      name: dev
      url: http://dev-api.internal

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBECONFIG_DEV }}" | base64 -d > kubeconfig
        export KUBECONFIG=./kubeconfig
        kubectl cluster-info

    - name: Apply namespace and configs
      run: |
        export KUBECONFIG=./kubeconfig
        kubectl apply -f k8s/dev/namespace.yaml
        kubectl apply -f k8s/dev/configmap.yaml
        kubectl apply -f k8s/dev/secrets.yaml

    - name: Apply database resources
      run: |
        export KUBECONFIG=./kubeconfig
        kubectl apply -f k8s/dev/postgres/
        kubectl apply -f k8s/dev/redis/
        echo "Waiting for databases to be ready..."
        kubectl wait --for=condition=ready pod -l app=postgres -n rs-service-dev --timeout=300s || true
        kubectl wait --for=condition=ready pod -l app=redis -n rs-service-dev --timeout=300s || true

    - name: Run database migrations
      run: |
        export KUBECONFIG=./kubeconfig
        kubectl delete job db-migration -n rs-service-dev --ignore-not-found
        kubectl apply -f k8s/dev/migration-job.yaml
        kubectl wait --for=condition=complete --timeout=300s job/db-migration -n rs-service-dev || \
          (kubectl logs -l app=migration -n rs-service-dev && exit 1)

    - name: Deploy API service
      run: |
        export KUBECONFIG=./kubeconfig
        kubectl apply -f k8s/dev/api/
        kubectl rollout status deployment/api -n rs-service-dev --timeout=300s

    - name: Verify deployment
      run: |
        export KUBECONFIG=./kubeconfig
        kubectl get pods -n rs-service-dev
        kubectl get svc -n rs-service-dev

  deploy-staging:
    name: Deploy to Staging Environment
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/release'
    environment:
      name: staging
      url: https://api-staging.example.com

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > kubeconfig
        export KUBECONFIG=./kubeconfig
        kubectl cluster-info

    - name: Apply namespace and configs
      run: |
        export KUBECONFIG=./kubeconfig
        kubectl apply -f k8s/staging/namespace.yaml
        kubectl apply -f k8s/staging/configmap.yaml
        kubectl apply -f k8s/staging/secrets.yaml

    - name: Apply database resources
      run: |
        export KUBECONFIG=./kubeconfig
        kubectl apply -f k8s/staging/postgres/
        kubectl apply -f k8s/staging/redis/
        echo "Waiting for databases to be ready..."
        kubectl wait --for=condition=ready pod -l app=postgres -n rs-service-staging --timeout=300s || true
        kubectl wait --for=condition=ready pod -l app=redis -n rs-service-staging --timeout=300s || true

    - name: Run database migrations
      run: |
        export KUBECONFIG=./kubeconfig
        kubectl delete job db-migration -n rs-service-staging --ignore-not-found
        kubectl apply -f k8s/staging/migration-job.yaml
        kubectl wait --for=condition=complete --timeout=300s job/db-migration -n rs-service-staging || \
          (kubectl logs -l app=migration -n rs-service-staging && exit 1)

    - name: Deploy API service
      run: |
        export KUBECONFIG=./kubeconfig
        kubectl apply -f k8s/staging/api/
        kubectl rollout status deployment/api -n rs-service-staging --timeout=300s

    - name: Verify deployment
      run: |
        export KUBECONFIG=./kubeconfig
        kubectl get pods -n rs-service-staging
        kubectl get svc -n rs-service-staging
        kubectl get ingress -n rs-service-staging

  deploy-prod:
    name: Deploy to Production Environment
    runs-on: ubuntu-latest
    needs: build-and-push
    if: startsWith(github.ref, 'refs/tags/v')
    environment:
      name: production
      url: https://api.example.com

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBECONFIG_PROD }}" | base64 -d > kubeconfig
        export KUBECONFIG=./kubeconfig
        kubectl cluster-info

    - name: Apply namespace and configs
      run: |
        export KUBECONFIG=./kubeconfig
        kubectl apply -f k8s/prod/namespace.yaml
        kubectl apply -f k8s/prod/configmap.yaml
        # Note: Secrets should be created manually in production
        # kubectl apply -f k8s/prod/secrets.yaml

    - name: Apply external service endpoints
      run: |
        export KUBECONFIG=./kubeconfig
        kubectl apply -f k8s/prod/external-services/

    - name: Run database migrations
      run: |
        export KUBECONFIG=./kubeconfig
        kubectl delete job db-migration -n rs-service-prod --ignore-not-found
        kubectl apply -f k8s/prod/migration-job.yaml
        kubectl wait --for=condition=complete --timeout=600s job/db-migration -n rs-service-prod || \
          (kubectl logs -l app=migration -n rs-service-prod && exit 1)

    - name: Deploy API service
      run: |
        export KUBECONFIG=./kubeconfig
        kubectl apply -f k8s/prod/api/
        kubectl rollout status deployment/api -n rs-service-prod --timeout=600s

    - name: Verify deployment
      run: |
        export KUBECONFIG=./kubeconfig
        kubectl get pods -n rs-service-prod
        kubectl get svc -n rs-service-prod
        kubectl get ingress -n rs-service-prod
        echo "Production deployment completed successfully!"

  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    needs: deploy-prod
    permissions:
      contents: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        generate_release_notes: true
        draft: false
        prerelease: false
        body: |
          ## Docker Images

          All service images have been built and pushed to GitHub Container Registry:

          - `ghcr.io/${{ github.repository }}-api:${{ github.ref_name }}`
          - `ghcr.io/${{ github.repository }}-worker:${{ github.ref_name }}`
          - `ghcr.io/${{ github.repository }}-grpc:${{ github.ref_name }}`
          - `ghcr.io/${{ github.repository }}-cli:${{ github.ref_name }}`

          ## Deployment

          The release has been automatically deployed to production.
